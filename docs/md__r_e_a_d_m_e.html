<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>refl-cpp: README</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
  $(document).ready(function() { init_search(); });
/* @license-end */
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">refl-cpp
   </div>
  </td>
   <td>        <div id="MSearchBox" class="MSearchBoxInactive">
        <span class="left">
          <img id="MSearchSelect" src="search/mag_sel.png"
               onmouseover="return searchBox.OnSearchSelectShow()"
               onmouseout="return searchBox.OnSearchSelectHide()"
               alt=""/>
          <input type="text" id="MSearchField" value="Search" accesskey="S"
               onfocus="searchBox.OnSearchFieldFocus(true)" 
               onblur="searchBox.OnSearchFieldFocus(false)" 
               onkeyup="searchBox.OnSearchFieldChange(event)"/>
          </span><span class="right">
            <a id="MSearchClose" href="javascript:searchBox.CloseResultsWindow()"><img id="MSearchCloseImg" border="0" src="search/close.png" alt=""/></a>
          </span>
        </div>
</td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(document).ready(function(){initNavTree('md__r_e_a_d_m_e.html',''); initResizable(); });
/* @license-end */
</script>
<div id="doc-content">
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

<div class="PageDoc"><div class="header">
  <div class="headertitle">
<div class="title">README </div>  </div>
</div><!--header-->
<div class="contents">
<div class="textblock"><center> <object type="image/svg+xml" data="https://raw.githubusercontent.com/veselink1/refl-cpp/master/branding/logo.svg?sanitize=true" style="pointer-events: none; max-width: 100%;" height="140">refl-cpp Logo</object></center><center><a href="https://github.com/veselink1/refl-cpp/graphs/contributors"><object type="image/svg+xml" data="https://img.shields.io/github/contributors/veselink1/refl-cpp.svg" style="pointer-events: none;">Contributors</object></a> <a href="https://github.com/veselink1/refl-cpp/pulse"><object type="image/svg+xml" data="https://img.shields.io/github/commit-activity/m/veselink1/refl-cpp.svg" style="pointer-events: none;">Activity</object></a> <a href="https://circleci.com/gh/veselink1/refl-cpp"><object type="image/svg+xml" data="https://circleci.com/gh/veselink1/refl-cpp.svg?style=shield" style="pointer-events: none;">CircleCI</object></a> <a href="https://gitter.im/refl-cpp/community?utm_source=badge&amp;utm_medium=badge&amp;utm_campaign=pr-badge"><object type="image/svg+xml" data="https://badges.gitter.im/refl-cpp/community.svg" style="pointer-events: none;">Gitter</object></a> <a href="https://liberapay.com/veselink1/donate"><object type="image/svg+xml" data="https://img.shields.io/liberapay/patrons/veselink1.svg?logo=liberapay" style="pointer-events: none;">Patrons</object></a> <a href="https://aur.archlinux.org/packages/refl-cpp"><img src="https://img.shields.io/aur/version/refl-cpp?logo=arch-linux" alt="AUR version" class="inline"/></a></center><center></center><h2><a class="anchor" id="autotoc_md25"></a>
refl-cpp v0.12.1 [&lt;a href="https://veselink1.github.io/refl-cpp/md__introduction.html"&gt;Documentation&lt;/a&gt;]</h2>
<p>A compile-time reflection library for modern C++ with support for overloads, templates, attributes and proxies</p>
<h2><a class="anchor" id="autotoc_md26"></a>
Introduction</h2>
<p><b><a href="https://github.com/veselink1/refl-cpp">refl-cpp</a> allows static reflection and inspection of types in C++17! On top of that, refl-cpp is extensible (build your own abstraction or runtime reflection system) and supports all of the following and more:</b></p><ul>
<li><b>overloaded and template functions</b> - invoke and get pointers to overloaded functions without specifying type arguments in metadata</li>
<li><b>template types</b> - reflect and work with template classes like regular classes</li>
<li><b>constexpr attributes</b>- attach custom objects to reflectable members and types (create your own markers, names for external bindings or arbitrary data)</li>
<li><b>proxy types</b> - programmatic type generation (implement unknown interface, create a generic <em>builder</em>, <em>value type wrapper</em>, etc.)</li>
</ul>
<h2><a class="anchor" id="autotoc_md27"></a>
Requirements</h2>
<ul>
<li>Minimum language standard: C++17</li>
</ul>
<h2><a class="anchor" id="autotoc_md28"></a>
Usage</h2>
<ul>
<li>refl-cpp is packaged as a header-only library! Simply <code>#include "refl.hpp"</code> just like any other header.</li>
</ul>
<h2><a class="anchor" id="autotoc_md29"></a>
License</h2>
<ul>
<li>MIT License (for more details, see the <a href="https://github.com/veselink1/refl-cpp/blob/master/LICENSE">license file</a>)</li>
</ul>
<h2><a class="anchor" id="autotoc_md30"></a>
Contributing</h2>
<p>See <a href="https://github.com/veselink1/refl-cpp/blob/master/contributors.md">contributors.md</a></p>
<p><a href="https://github.com/veselink1/refl-cpp">refl-cpp</a> is publicly open for any contribution. Bugfixes and new features are welcome. Extra modules are too (as long as the single-header usability is preserved and the functionality is not overly specific to particular use case).</p>
<h2><a class="anchor" id="autotoc_md31"></a>
Donations</h2>
<p>Donations are wholeheartedly accepted and will help support this library long term! If you are using refl-cpp in your project and it's making your work easier, please consider making a donation!</p>
<p><a href="https://liberapay.com/veselink1/donate"><object type="image/svg+xml" data="https://liberapay.com/assets/widgets/donate.svg" style="pointer-events: none;">Donate</object></a></p>
<h2><a class="anchor" id="autotoc_md32"></a>
Getting started</h2>
<p>See the <a href="https://veselink1.github.io/refl-cpp/md__introduction.html">Introduction</a> for a quick overview of refl-cpp.</p>
<h2><a class="anchor" id="autotoc_md33"></a>
Examples</h2>
<ul>
<li><b>Implement a simple serialization system</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-serialization.cpp">example-serialization.cpp</a> Shows how to implement a very efficient and generic serialization procedure from scratch</li>
<li><b>Implement a generic builder class factory</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-builders.cpp">example-builders.cpp</a> Shows how to utilize refl-cpp proxy classes to define a generic <code>builder&lt;T&gt;</code> class, which implements the builder pattern</li>
<li><b>Simple SQL database abstraction</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-dao.cpp">example-dao.cpp</a> Shows how to implement a basic ORM system which can generate SQL statements at compile-time from model classes using custom properties</li>
<li><b>Iterate base classes with <code>bases&lt;&gt;</code></b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-inheritance.cpp">example-inheritance.cpp</a> Shows to use the built-in <code>bases&lt;&gt;</code> attribute to iterate over a type's base classes</li>
<li><b>Access reflection information at runtime</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-custom-rtti.cpp">example-custom-rtti.cpp</a> Shows how to implement a basic runtime abstraction over refl-cpp which provides access to the reflection metadata at runtime via custom metadata objects</li>
<li><b>Type factories with proxies</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-proxy.cpp">example-proxy.cpp</a> Shows to implement a basic type factory that exposes target type fields as functions</li>
<li><b>XML-based GUI with strongly-types properties</b> - <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-binding.cpp">example-binding.cpp</a> Shows how to implement a system for reading XML resources describing a UI for an imaginary GUI system with refl-cpp</li>
</ul>
<h3><a class="anchor" id="autotoc_md34"></a>
Basic usage example</h3>
<p>A basic example showcasing how refl-cpp can be use to convert an arbitrary type to a tuple at compile-time </p><div class="fragment"><div class="line"><span class="keyword">struct </span>Point {</div>
<div class="line">  <span class="keywordtype">float</span> x;</div>
<div class="line">  <span class="keywordtype">float</span> y;</div>
<div class="line">};</div>
<div class="line"> </div>
<div class="line"><span class="comment">/* Metadata */</span></div>
<div class="line">REFL_AUTO(</div>
<div class="line">  type(Point),</div>
<div class="line">  field(x, <span class="comment">/* attributes */</span>),</div>
<div class="line">  field(y)</div>
<div class="line">)</div>
<div class="line"> </div>
<div class="line">Point pt{};</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Converting to an std::tuple: (Note the constexpr!)</span></div>
<div class="line">constexpr <span class="keyword">auto</span> values = <a class="code" href="namespacerefl_1_1util.html#adb5bb478ef1cc5966e9df7c9b10b5dd3">map_to_tuple</a>(<a class="code" href="namespacerefl.html#ae95fbc2d63a7db5ce4d8a4dcca3d637e">refl::reflect</a>(pt).members, [&amp;](<span class="keyword">auto</span> member) {</div>
<div class="line">  <span class="comment">// refl::descriptor::is_readable (found by Koenig lookup)</span></div>
<div class="line">  <span class="keywordflow">if</span> constexpr (<a class="code" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">is_readable</a>(member)) {</div>
<div class="line">    <span class="keywordflow">return</span> member(pt); <span class="comment">// invoke the member</span></div>
<div class="line">  }</div>
<div class="line">})</div>
<div class="line"><span class="comment">// Result: values == std::tuple&lt;int, int&gt;{ 0, 0 };</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md35"></a>
How it works</h2>
<p>Warning: Content might be outdated</p><ul>
<li>Introductory post - <a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/06/08/compile-time-reflection-cpp-17.html">Compile-time reflection in C++ 17</a></li>
<li>In-depth post - <a href="https://veselink1.github.io/blog/cpp/metaprogramming/2019/07/13/refl-cpp-deep-dive.html">refl-cpp — A deep dive</a></li>
</ul>
<h2><a class="anchor" id="autotoc_md36"></a>
Metadata-generation macros</h2>
<div class="fragment"><div class="line"><span class="comment">// Describes a type and all of its members</span></div>
<div class="line">REFL_AUTO(</div>
<div class="line">  type(Name, Attribute...),</div>
<div class="line">  field(Name, Attribute...),</div>
<div class="line">  func(Name, Attribute...)</div>
<div class="line">)</div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md37"></a>
Old style macros</h2>
<div class="fragment"><div class="line"><span class="comment">// Starts the declaration of Type&#39;s metadata.</span></div>
<div class="line"><span class="comment">// Must be followed by one of: REFL_END, REFL_FIELD, REFL_FUNC.</span></div>
<div class="line"><span class="comment">// Example: REFL_TYPE(Dog, bases&lt;Animal&gt;)</span></div>
<div class="line"><a class="code" href="refl_8hpp.html#a2d90ffbabd9fc8cc17579fc33d919d71">REFL_TYPE</a>(Type, Attributes...)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Starts the declaration of Type&#39;s metadata.</span></div>
<div class="line"><span class="comment">// Must be followed by one of: REFL_END, REFL_FIELD, REFL_FUNC.</span></div>
<div class="line"><span class="comment">// Example: REFL_TEMPLATE((typename K, typename V), (std::pair&lt;K, V&gt;))</span></div>
<div class="line"><a class="code" href="refl_8hpp.html#a832b795bfa32d4130b04e9e33635c507">REFL_TEMPLATE</a>((typename... Ts), (Type&lt;Ts...&gt;)), Attributes...)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// End the declaration of Type&#39;s metadata.</span></div>
<div class="line"><span class="comment">// Does not have an argument list</span></div>
<div class="line">REFL_END</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Describes a field.</span></div>
<div class="line"><span class="comment">// Example: REFL_FIELD(first_name, property{ &quot;Value&quot; })</span></div>
<div class="line">REFL_FIELD(Field, Attributes...)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// Describes a function.</span></div>
<div class="line"><span class="comment">// Example: REFL_FUNC(first_name, property{ &quot;Size&quot; })</span></div>
<div class="line">REFL_FUNC(Function, Attribute...)</div>
<div class="line"> </div>
<div class="line"><span class="comment">// NOTE: None of the macros above need a terminating semi-colon (;)</span></div>
</div><!-- fragment --><h2><a class="anchor" id="autotoc_md38"></a>
Changelog</h2>
<p><em>Releases follow the <code>MAJOR.MINOR.PATCH</code> versioning scheme</em></p>
<p><code>Major</code> denotes a very big change in the structure of the library.</p>
<p><code>Minor</code> denotes a smaller change, which usually includes new features and might also change or even remove certain features.</p>
<p><code>Patch</code> denotes a version which fixed a bug or does not include major new features.</p>
<hr  />
 <h3><a class="anchor" id="autotoc_md40"></a>
v0.12.1</h3>
<ul>
<li>Fixed broken build on Visual Studio 2017 <a href="https://github.com/veselink1/refl-cpp/issues/39">#39</a> (9b6aa1a)</li>
<li>Fixed out-of-bounds read in <code><a class="el" href="namespacerefl_1_1runtime.html#a06e1996b05966eac4f282b6656169d6a">refl::runtime::debug</a></code> implementation for <code>basic_string_view</code> (93351ac)</li>
<li>Fixed unused function warning for <code>refl::runtime::detail::next_depth</code> #36 (by <a href="https://github.com/oberrich">oberrich</a>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md41"></a>
v0.12.0</h3>
<ul>
<li>Added <code><a class="el" href="classstd_1_1complex.html">std::complex</a></code> support metadata. Disable with <code>REFL_NO_STD_COMPLEX</code>.</li>
<li>Added <code><a class="el" href="namespacerefl_1_1descriptor.html#a3690f579517cc28e9d2eacb3d095fdbb" title="Returns a member that has the same display name as the one provied and is readable.">refl::descriptor::get_reader</a></code>/<code>get_writer</code> utilities for getter/setter properties.</li>
<li>Added <code>refl::trait::index_of</code> for finding index of type in a <code>type_list</code>.</li>
<li>Added <code><a class="el" href="namespacerefl_1_1descriptor.html#a7cb65ca47183b468df2b8429dc5dea61" title="Returns the display name of T as a const_string&lt;N&gt;.">refl::descriptor::get_display_name_const</a></code> as <code>const_string</code> alternative to <code>get_display_name</code>.</li>
<li>Fixed #33 (by <a href="https://github.com/james-conrad">james-conrad</a>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md42"></a>
v0.11.0</h3>
<ul>
<li>Much improved support for inheritance (<a href="https://github.com/veselink1/refl-cpp/issues/27">#27</a>, <a href="https://github.com/veselink1/refl-cpp/issues/28">#28</a>)<ul>
<li><code><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html#a47c4ff48babd4b3c949a9f20fd4cfca2" title="The declared base types (via base_types&lt;Ts...&gt; attribute) of T.">refl::type_descriptor::declared_bases</a></code> lists base types declared via the <code>bases&lt;...&gt;</code> attribute</li>
<li><code><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html#a49cb64fdc7142034426db38142cfa67b" title="The declared and inherited base types of T.">refl::type_descriptor::bases</a></code> lists base types declared via the <code>bases&lt;...&gt;</code> attribute as well as inherited members</li>
<li><code><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html#a48f1fddd822d40866a30bf1ebd60fa1a" title="The list of declared and inherited member descriptors.">refl::type_descriptor::members</a></code> now includes declared and inherited members (when base types are specified via <code>bases&lt;...&gt;</code> attribute)</li>
<li><code><a class="el" href="classrefl_1_1descriptor_1_1type__descriptor.html#a49d984bc4bcb37717d3dc95a1815a4ba" title="The list of declared member descriptors.">refl::type_descriptor::declared_members</a></code> preserves the old behavior</li>
<li><code>refl::attr::bases&lt;...&gt;</code> types are now validated (via <code>std::is_base_of</code>)</li>
</ul>
</li>
<li>Added <code><a class="el" href="namespacerefl_1_1descriptor.html#a5621e8b981bfb910f027fb720320f977" title="Returns the unqualified name of the type, discarding the namespace and typenames (if a template type)...">refl::descriptor::get_simple_name</a></code>, which strips namespace and template declarations from the type name (<code>std::vector&lt;int&gt;</code> -&gt; <code>vector</code>)</li>
<li>Added free function equivalents of members of <code>_descriptor</code> types for symmetry purposes (and might allow for more optimal implementation in the future)</li>
<li>Added <code><a class="el" href="structrefl_1_1util_1_1const__string.html#a90d93009e7ae4bccec928c9342b197af" title="Searches the string for the first occurrence of the character and returns its position.">refl::const_string::find</a>/rfind</code> for searching chars in const_strings</li>
<li>Added <code>refl::make_const_string(char)</code> overload</li>
<li>Added <code>refl::type_list&lt;T&gt;</code> specialization which exposes <code>typedef T type</code> and a synonym <code>refl::type_tag&lt;T&gt;</code></li>
<li><code><a class="el" href="structrefl_1_1trait_1_1concat.html" title="Concatenates N lists together.">refl::trait::concat</a></code> now support an arbitrary number of <code>type_list</code>s as type arguments</li>
<li>Added <code>refl::trait::as_tuple</code> (similar to <code>as_type_list</code> but for <code>std::tuple</code>)</li>
<li>Added <code><a class="el" href="structrefl_1_1trait_1_1reverse.html" title="Reverses a list of types.">refl::trait::reverse</a></code></li>
<li>Added <code><a class="el" href="namespacerefl_1_1util.html#a7dfb7f94fdcfc69947d40143b3a07d65" title="Converts a type_list of types to a type_list of the type_descriptors for these types.">refl::util::reflect_types</a></code>/<code><a class="el" href="namespacerefl_1_1util.html#ad67a3c06ac31131661f1fb1cee670fbc" title="Converts a type_list of type_descriptors to a type_list of the target types.">refl::util::unreflect_types</a></code> to quickly create a list of <code>type_descriptor</code>s from a list of types and then back</li>
<li>Introduced support for different types of <code>std::basic_ostream</code> in <code>attr::debug</code> and <code>util::debug</code> (up to the user to take advantage of)</li>
<li>Built-in support for <code>std::string_view</code></li>
<li>More type assertions in <code>descriptor::</code> utilities</li>
<li>Simplification of some <code>trait::</code> types (should lead to better compile-times)</li>
<li>Made unit tests more comprehensive</li>
<li>Fixed incorrect <code><a class="el" href="namespacerefl_1_1util.html#aa9940e0488744c7466f3410f6acce07b" title="Returns the input paratemeter as-is.">refl::util::identity</a></code> implementation for rvalues</li>
<li>Fixed static function invocation with <code>operator()/invoke</code></li>
<li>Fixed <code>refl::util::debug</code> for <code>std::tuple</code> <a href="https://github.com/veselink1/refl-cpp/issues/26">#26</a></li>
<li>Deprecated <code><a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938" title="Returns a list of the type_descriptor&lt;T&gt;s of the base types of the target, as specified by the bases&lt;...">refl::descriptor::get_bases</a></code> in favor of <code><a class="el" href="namespacerefl_1_1descriptor.html#afc445cfd9be739891c2b6731047cf144" title="Returns a type_list of the declared and inherited base types of the type.">refl::descriptor::get_base_types</a></code></li>
</ul>
<h3><a class="anchor" id="autotoc_md43"></a>
v0.10.0</h3>
<ul>
<li>Introduced automatic property name normalization in <code>get_display_name</code> for properties with no <code>friendly_name</code>. Example: <code>get_display_name(get_foo) -&gt; "foo"</code></li>
<li>Added built-in reflection support for <code>std::string_view</code> <a href="https://github.com/veselink1/refl-cpp/issues/23">#23</a></li>
<li>Fixed: operations on <code>type_list</code> do not properly take into account reference qualifiers</li>
<li>Fixed <code>const_string</code> constructor in older versions of clang</li>
<li>Fixed <code>util::filter</code> results list order (used to be reversed)</li>
<li>Fixed implementation of <code>reflect</code>, <code>is_reflectable</code>, <code>debug</code></li>
<li>Improved <code>runtime::debug</code> print formatting</li>
<li>Removed filtering by <code>const_string</code> utils <a href="https://github.com/veselink1/refl-cpp/issues/21">#21</a>. Suggested workaround: use predicate variants</li>
<li>Removed refl-ht support</li>
<li>Code cleanup <a href="https://github.com/veselink1/refl-cpp/issues/24">#24</a>, <a href="https://github.com/veselink1/refl-cpp/issues/20">#20</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md44"></a>
v0.9.1</h3>
<ul>
<li>Bugfix for <code><a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938" title="Returns a list of the type_descriptor&lt;T&gt;s of the base types of the target, as specified by the bases&lt;...">refl::descriptor::get_bases</a></code> for clang <a href="https://github.com/veselink1/refl-cpp/issues/19">#19</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md45"></a>
v0.9.0</h3>
<ul>
<li>Introduced <code><a class="el" href="namespacerefl_1_1descriptor.html#a725c882cfae058b70d50517fe134a938" title="Returns a list of the type_descriptor&lt;T&gt;s of the base types of the target, as specified by the bases&lt;...">refl::descriptor::get_bases</a></code> (as well as <code><a class="el" href="namespacerefl_1_1descriptor.html#ac00126ab409dbc1a5445d37832876fe2" title="Checks if a type has a bases attribute.">refl::descriptor::has_bases</a></code>) to inspect a type's declared base types (see <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-inheritance.cpp">example-inheritance.cpp</a>)</li>
<li>Bugfix for is_instance_of for template types with different arity <a href="https://github.com/veselink1/refl-cpp/issues/18">#18</a></li>
<li>Renamed <code>refl::descriptor::get_property_info</code> to <code><a class="el" href="namespacerefl_1_1descriptor.html#aadb1bb89c2469071ced6551ca3b9b8fd" title="Gets the property attribute.">refl::descriptor::get_property</a></code> to match the attribute name and its trait-based counterparts.</li>
<li>Discontinued <a href="https://github.com/veselink1/refl-ht">refl-ht</a> - the preprocessor for refl-cpp, due to unfixable bugs and lack of time/interest.</li>
</ul>
<h3><a class="anchor" id="autotoc_md46"></a>
v0.8.2</h3>
<ul>
<li>CV-qualifiers are now properly removed from attribute objects (previously, the values in the backing <code>std::tuple&lt;...&gt;</code> were sometimes cv-qualified).</li>
</ul>
<h3><a class="anchor" id="autotoc_md47"></a>
v0.8.1</h3>
<ul>
<li>Fixed a bug that prevented the compilation of <code><a class="el" href="namespacerefl_1_1descriptor.html#a9f021ce9c4ef95ab4313aefb8f4f3588" title="Returns the display name of T.">refl::descriptor::get_display_name()</a></code> in some compilers (thanks to <a href="https://github.com/ticelo">ticelo</a>)</li>
<li>Removed improper usage of <code>[[maybe_unused]]</code> that caused warnings under clang.</li>
</ul>
<h3><a class="anchor" id="autotoc_md48"></a>
v0.8.0</h3>
<ul>
<li>Added the ability to create <code>refl::const_string&lt;N&gt;</code> instances from <code>const char*</code> which allows using c-strings (<code>const char*</code>) values from attributes together with <code>const_string&lt;N&gt;</code> and in <code>constexpr</code> context possible. That feature is exposed by the <code><a class="el" href="refl_8hpp.html#a2cb939da062920a29a38dff73aaf0968" title="Converts a compile-time available const char* value to a const_string&lt;N&gt;.">REFL_MAKE_CONST_STRING(CString)</a></code> macro. Important: <code>CString</code> must be a <a href="https://en.cppreference.com/w/cpp/language/constant_expression#Core_constant_expressions">Core constant expression</a>. The macro is necessary to avoid the duplication of the provided expression and currently expands to ~ <code>detail::copy_from_unsized&lt;detail::strlen(CString)&gt;(CString)</code>. (another thanks to <a href="https://github.com/Siapran">Siapran</a> for contributing the implementation for the <code>constexpr length()</code> function.)</li>
</ul>
<h3><a class="anchor" id="autotoc_md49"></a>
v0.7.0</h3>
<ul>
<li>Added <code>constexpr const_string::substr&lt;Pos, [Count]&gt;()</code></li>
<li>Added <code><a class="el" href="namespacerefl_1_1util.html#a4902f2250ab00bb4884b348893fb7641" title="Creates an empty instance of const_string&lt;N&gt;">make_const_string()</a></code> as a shortcut for the creation of empty const strings.</li>
<li>Added <code>trait::{first, last, tail, init, append, prepend, reverse, concat}</code> and <code>TraitName_t</code> equivalents to ease the use of <code>type_list&lt;...&gt;</code>.</li>
<li>Breaking change: <code>trait::map</code> and <code>trait::filter</code> now no longer accept variadic template parameters. Wrap variadic parameters in a type_list. (Allowing both <code>type_list&lt;Ts...&gt;</code> and <code>Ts...</code> is problematic due to cryptic errors when e.g. <code>const type_list&lt;Ts...&gt;</code> is provided.)</li>
<li>Breaking change: <code>util::accumulate</code> now mimics the behaviour of <code>std::accumulate</code> more closely. It relies on the return value of the functor instead of mutating the accumulator argument. The new implementation now allows for the types of <code>initial_value</code> and the return type to differ (thanks to <a href="https://github.com/Siapran">Siapran</a>).</li>
<li>Removed: <code>util::get&lt;N&gt;(const type_list&lt;Ts...&gt;&amp;)</code>. Use <code>trait::get_t&lt;N, type_list&lt;Ts...&gt;&gt;</code> instead. This is part of a move towards minimizing the duplication between the <code>trait::</code> and <code>util::</code> namespaces.</li>
<li>Added two new examples: <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-binding.cpp">example-binding.cpp</a> and <a href="https://github.com/veselink1/refl-cpp/blob/master/examples/example-dao.cpp">example-dao.cpp</a> to present some of the new things introduced in this release. (example-dao.cpp based on work by <a href="https://github.com/Siapran">Siapran</a>)</li>
</ul>
<h3><a class="anchor" id="autotoc_md50"></a>
v0.6.5</h3>
<ul>
<li>Fixed multiple unused X warnings (fixed by <a href="https://github.com/Siapran">Siapran</a>) #12</li>
</ul>
<h3><a class="anchor" id="autotoc_md51"></a>
v0.6.4</h3>
<ul>
<li>Bugfix: usage of incorrect bound in <code>operator+(const_string&lt;N&gt;, const_string&lt;M&gt;)</code> (fixed by <a href="https://github.com/Siapran">Siapran</a>) #11</li>
</ul>
<h3><a class="anchor" id="autotoc_md52"></a>
v0.6.3</h3>
<ul>
<li>Bugfix: clang errors during compilation of reflected overloaded member functions (since 0.6.0)</li>
</ul>
<h3><a class="anchor" id="autotoc_md53"></a>
v0.6.2</h3>
<ul>
<li>Bugfix: Compiler error in clang: <a class="el" href="structrefl_1_1attr_1_1property.html" title="Used to decorate a function that serves as a property.">refl::attr::property</a>'s implicitly-declared default constructor is deleted due to N3797 §8.5/7 <a href="https://github.com/veselink1/refl-cpp/issues/9">#9</a></li>
</ul>
<h3><a class="anchor" id="autotoc_md54"></a>
v0.6.1</h3>
<ul>
<li>Bugfix: const_string::operator std::string() was incorrectly marked as constexpr which caused compilation failure in non-C++20-compliant compilers</li>
</ul>
<h3><a class="anchor" id="autotoc_md55"></a>
v0.6.0</h3>
<ul>
<li>Changed: property() is now only usable on function members / use contract based checks for functions and fields (is_readable/writable)</li>
<li>Removed: read_only, write_only, read_write access modifiers for property() attributes (rw-detection now based on contract).</li>
</ul>
<h3><a class="anchor" id="autotoc_md56"></a>
v0.5.2</h3>
<ul>
<li>Added: <code>type_descriptor&lt;T&gt;::type</code> as an alias for <code>T</code>.</li>
<li>Added: <code>function_descriptor&lt;T, N&gt;::pointer</code> which points to the target function, if the pointer can be resolved and to nullptr otherwise.</li>
<li>Added: <code>function_descriptor&lt;T, N&gt;::is_resolved</code> for checking whether the pointer to the function has been resolved successfully.</li>
<li>Added: <code>function_descriptor&lt;T, N&gt;::resolve&lt;Pointer&gt;</code> for explicitly resolving the function pointer as a value of the specified type.</li>
<li>Added: <code>util::get&lt;size_t N&gt;(type_list&lt;Ts...&gt;&amp;&amp;)</code> which zero-initializes and returns the type at the N-th position.</li>
<li>Added: <code>util::get&lt;size_t N&gt;(Tuple&amp;&amp;)</code> as an alias for <code>std::get&lt;N&gt;</code>.</li>
</ul>
<h3><a class="anchor" id="autotoc_md57"></a>
v0.5.1</h3>
<ul>
<li>Bugfix: The REFL_AUTO macro was not working properly in MSVC and led to Internal compiler errors</li>
<li>Changed: As a result of the related bugfix, the REFL_AUTO macro has been stabilized and its use is now recommended</li>
</ul>
<h3><a class="anchor" id="autotoc_md58"></a>
v0.5.0</h3>
<ul>
<li>Removed deprecated macros <code>$refl(...)</code>, <code>REFL_UNSTABLE(...)</code>, <code>REFL_DEPRECATED(...)</code></li>
<li>Removed deprecated <code>refl::attr::access_type::read, write</code> constants. Replaced by read_only, write_only for consistency.</li>
<li>Removed deprecated <code>refl::attr::read_only, read_write, write_only</code> constants. Use the enum-qualified values. The constants are still available unqualified in macro context.</li>
<li>Removed refl::descriptor::make_invoker (which was not deprecated but is now obsolete.) Simply replace make_invoker(x) with x.</li>
<li>The defaulted constructor for <code><a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">refl::util::const_string</a>&lt;N&gt;</code> was replaced by a user-declared default constructor which now always zero-initializes the string buffer.</li>
</ul>
<h3><a class="anchor" id="autotoc_md59"></a>
v0.4.2</h3>
<ul>
<li>Added: <code>trait::is_type[_v]</code>, <code>descriptor::is_type(const T&amp;)</code> for checking whether a type is a type_descriptor&lt;T&gt; instance.</li>
</ul>
<h3><a class="anchor" id="autotoc_md60"></a>
v0.4.1</h3>
<ul>
<li><code>trait::as_type_list</code> now supports reference type in place of <code>T&lt;Ts...&gt;</code> (e.g. <code>std::tuple&lt;Ts...&gt;&amp;</code> -&gt; <code>type_list&lt;Ts...&gt;</code>).</li>
<li><code>refl::attr::access_type::{read, write}</code> now deprecated, replaced by <code>{read_only, write_only}</code> (Note: implicitly-usable <code>read_only</code>, <code>write_only</code> constants in attribute (in <code>REFL_...</code> macros) context remain unchanged)</li>
<li><code>refl::descriptor::field_descriptor::operator()</code> now supports acting as a setter. <code>refl::descriptor::make_invoker</code> is now no longer needed and marked as deprecated.</li>
</ul>
<h3><a class="anchor" id="autotoc_md61"></a>
v0.4.0</h3>
<ul>
<li>Renamed: <code>trait::filter</code> to <code>trait::filter_t</code>, replaced by <code>struct trait::filter { typedef ... type; }</code> to follow preset convention</li>
<li>Renamed: <code>trait::map</code> to <code>trait::map_t</code>, replaced by <code>struct trait::map { typedef ... type; }</code> to follow preset convention</li>
<li>Breaking change: <code>function_descriptor&lt;...&gt;::pointer</code> now no longer exists. (Reason: Replacing with forwarding function allows for more flexibility when using <code><a class="el" href="structrefl_1_1runtime_1_1proxy.html" title="A proxy object that has a static interface identical to the reflected functions and fields of the tar...">refl::runtime::proxy</a>&lt;&gt;</code>. Migrate by taking a pointer to <code>function_descriptor&lt;...&gt;<a class="el" href="namespacerefl_1_1descriptor.html#ab17264f6fe5ef2e6f10a67304cb40e83" title="Invokes the member with the specified arguments.">invoke()</a></code>)</li>
<li>Breaking change: trait::contains/base/instance now no longer work implicitly with <code>std::tuple&lt;...&gt;</code> or support variadic arguments. Use <code>type_list&lt;&gt;</code> or <code>trait::as_type_list_t</code> to migrate working code. (Reason: Specializations found to be causative to many recently discovered bugs and are error-prone.)</li>
<li>Bugfix: faulty implementation of <code>trait::skip&lt;N&gt;</code></li>
<li>Bugfix: faulty implementation of <code>util::to_tuple</code></li>
<li>Bugfix: <code>trait::contains_base</code> was working the other way around (checking for presense of base of a specified type, instead of checking for a derived type with a specified base)</li>
</ul>
<h3><a class="anchor" id="autotoc_md62"></a>
v0.3.5</h3>
<ul>
<li>Bugfix: <code>type_info__&lt;T*&gt;</code> has name defined as <code>char[N]</code> instead of <code>const_string&lt;N&gt;</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md63"></a>
v0.3.4</h3>
<ul>
<li>added new experimental syntax for metadata declaration that makes use of variadic macro expansion (can be disabled with <code>REFL_NO_VARIADICS</code>) <div class="fragment"><div class="line">REFL_AUTO</div>
<div class="line">(</div>
<div class="line">    type(User), <span class="comment">// expands to REFL_TYPE(User)</span></div>
<div class="line">    field(<span class="keywordtype">id</span>, property(read_only)), <span class="comment">// expands to REFL_FIELD(id, property(read_only))</span></div>
<div class="line">    field(email),</div>
<div class="line">    field(first_name, property(<span class="stringliteral">&quot;firstName&quot;</span>)),</div>
<div class="line">    field(last_name, property(<span class="stringliteral">&quot;lastName&quot;</span>))</div>
<div class="line">    func(save_to_db) <span class="comment">// expands to REFL_FUNC(save_to_db)</span></div>
<div class="line">) <span class="comment">// REFL_END appended automatically</span></div>
</div><!-- fragment --></li>
</ul>
<h3><a class="anchor" id="autotoc_md64"></a>
v0.3.3</h3>
<ul>
<li><code><a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">refl::util::const_string</a>&lt;N&gt;</code> can now be directly compared for equality with <code>char[M]</code></li>
<li><code><a class="el" href="structrefl_1_1util_1_1const__string.html" title="Represents a compile-time string.">refl::util::const_string</a>&lt;N&gt;</code> can now be concatenated with <code>char[M]</code></li>
</ul>
<h3><a class="anchor" id="autotoc_md65"></a>
v0.3.2</h3>
<ul>
<li><code><a class="el" href="namespacerefl_1_1runtime.html#a06e1996b05966eac4f282b6656169d6a">refl::runtime::debug</a></code> now captures values of member invocations by universal references (previous implementations required a copy of the value)</li>
<li><code><a class="el" href="namespacerefl_1_1runtime.html#a06e1996b05966eac4f282b6656169d6a">refl::runtime::debug</a></code> now does not require the members of composites to be reflectable. (members that cannot be printed get replaced with <code>&lt;?&gt;</code>).</li>
<li><code><a class="el" href="structrefl_1_1trait_1_1is__reflectable.html" title="Checks whether there is reflection metadata for the type T.">refl::trait::is_reflectable</a></code> now discards cv-qualifiers -&gt; all cv-qualified types are now also reflectable.</li>
</ul>
<h3><a class="anchor" id="autotoc_md66"></a>
v0.3.1</h3>
<ul>
<li><code><a class="el" href="namespacerefl_1_1descriptor.html#a925e8cb99d6199fe03edeb5109958f8d" title="Checks if T is a 1-arg non-const-qualified member function with a property attribute or a non-const f...">refl::descriptor::is_writable</a></code> now correctly supports field descriptors</li>
<li>most of <code><a class="el" href="refl_8hpp.html">refl.hpp</a></code> is now not included when <code>REFL_PREPROCESSOR</code> is defined (optimization for refl-ht)</li>
</ul>
<h3><a class="anchor" id="autotoc_md67"></a>
v0.3.0</h3>
<ul>
<li>added new <code>REFL(...)</code> macro for annotation of reflectable members (replaces <code>$refl(...)</code>)</li>
<li><code>$refl(...)</code> macro usage now deprecated</li>
</ul>
<h3><a class="anchor" id="autotoc_md68"></a>
v0.2.1</h3>
<ul>
<li>added support for <a href="https://github.com/veselink1/refl-ht">refl-ht</a> (the refl-cpp header tool)</li>
</ul>
<h3><a class="anchor" id="autotoc_md69"></a>
v0.2.0</h3>
<ul>
<li>added <code><a class="el" href="namespacerefl_1_1util.html#ab78f978c331cb63b1450c0adbf093998" title="Returns true if any item in the list matches the predicate.">refl::util::contains</a>(type_list&lt;...&gt;, [predicate]), <a class="el" href="namespacerefl_1_1util.html#ab78f978c331cb63b1450c0adbf093998" title="Returns true if any item in the list matches the predicate.">refl::util::contains</a>(type_list&lt;...&gt;, const_string&lt;N&gt;)</code></li>
<li>removed <code>refl::attr::is_readable/is_writable</code> (use <code><a class="el" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab" title="Checks if T is a 0-arg const-qualified member function with a property attribute or a field.">refl::descriptor::is_readable</a>/is_writable</code> instead; reason: lack of support for fields that lack a property attribute)</li>
</ul>
<h3><a class="anchor" id="autotoc_md70"></a>
v0.1.2</h3>
<ul>
<li><code><a class="el" href="structrefl_1_1runtime_1_1proxy.html" title="A proxy object that has a static interface identical to the reflected functions and fields of the tar...">refl::runtime::proxy</a>&lt;Derived, Target&gt;</code> can now delegate field 'invocations'. (Methods with names matching those of the reflected fields are created.)</li>
<li><code><a class="el" href="structrefl_1_1attr_1_1property.html" title="Used to decorate a function that serves as a property.">refl::attr::property</a></code> now can take an optional <code>refl::attr::access_type</code> (values: <code>read_only</code>, <code>write_only</code>, <code>read_write</code>) to specify whether the property is considered readable or writable (or both).</li>
<li>added <code><a class="el" href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab" title="Checks if T is a 0-arg const-qualified member function with a property attribute or a field.">refl::descriptor::is_readable</a>/is_writable</code></li>
<li>added <code>refl::attr::is_readable/is_writable</code> </li>
</ul>
</div></div><!-- contents -->
</div><!-- PageDoc -->
</div><!-- doc-content -->
<div class="ttc" id="anamespacerefl_1_1descriptor_html_aa68bedab33d684ee5ee4ead24c5586ab"><div class="ttname"><a href="namespacerefl_1_1descriptor.html#aa68bedab33d684ee5ee4ead24c5586ab">refl::descriptor::is_readable</a></div><div class="ttdeci">constexpr bool is_readable(MemberDescriptor) noexcept</div><div class="ttdoc">Checks if T is a 0-arg const-qualified member function with a property attribute or a field.</div><div class="ttdef"><b>Definition:</b> refl.hpp:3060</div></div>
<div class="ttc" id="arefl_8hpp_html_a832b795bfa32d4130b04e9e33635c507"><div class="ttname"><a href="refl_8hpp.html#a832b795bfa32d4130b04e9e33635c507">REFL_TEMPLATE</a></div><div class="ttdeci">#define REFL_TEMPLATE(TemplateDeclaration, TypeName,...)</div><div class="ttdoc">Creates reflection information for a specified type template.</div><div class="ttdef"><b>Definition:</b> refl.hpp:4065</div></div>
<div class="ttc" id="anamespacerefl_html_ae95fbc2d63a7db5ce4d8a4dcca3d637e"><div class="ttname"><a href="namespacerefl.html#ae95fbc2d63a7db5ce4d8a4dcca3d637e">refl::reflect</a></div><div class="ttdeci">constexpr type_descriptor&lt; T &gt; reflect() noexcept</div><div class="ttdoc">Returns the type descriptor for the type T.</div><div class="ttdef"><b>Definition:</b> refl.hpp:3435</div></div>
<div class="ttc" id="anamespacerefl_1_1util_html_adb5bb478ef1cc5966e9df7c9b10b5dd3"><div class="ttname"><a href="namespacerefl_1_1util.html#adb5bb478ef1cc5966e9df7c9b10b5dd3">refl::util::map_to_tuple</a></div><div class="ttdeci">constexpr auto map_to_tuple(type_list&lt; Ts... &gt; list, F &amp;&amp;f)</div><div class="ttdoc">Applies function F to each type in the type_list, aggregating the results in a tuple.</div><div class="ttdef"><b>Definition:</b> refl.hpp:1591</div></div>
<div class="ttc" id="arefl_8hpp_html_a2d90ffbabd9fc8cc17579fc33d919d71"><div class="ttname"><a href="refl_8hpp.html#a2d90ffbabd9fc8cc17579fc33d919d71">REFL_TYPE</a></div><div class="ttdeci">#define REFL_TYPE(TypeName,...)</div><div class="ttdoc">Creates reflection information for a specified type.</div><div class="ttdef"><b>Definition:</b> refl.hpp:4048</div></div>
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.17 </li>
  </ul>
</div>
</body>
</html>
